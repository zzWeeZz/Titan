#version 460

#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_16bit_storage: require
#extension GL_NV_mesh_shader: require

layout (local_size_x = 1) in;
layout (triangles, max_vertices = 64, max_primitives = 124) out;

const uint g_TriangleLoops = (3 * 126 + 4 * 1 - 1) / (1 * 4);

layout (location = 0) out PerVertexData
{
	vec4 color;
} v_out[];


layout (binding = 0) uniform MvpBufferObject
{
	mat4 view;
	mat4 proj;
	mat4 mdlSpace;
} u_MvpObject;

struct Vertex
{
	vec3 Position;
	vec3 Color;
	vec3 Normal;
	vec3 Tangent; 
	vec2 TexCoords;
};

layout (std430, binding = 1) buffer _vertices
{
  Vertex vertices[];
} u_VertexBuffer;

layout (std430, binding = 2) buffer _triangles
{
  uint triangles[];
} u_TriangleBuffer;

struct Meshlet
{
  uint vertexOffset;
  uint triangleOffset;
  uint vertexCount;
  uint triangleCount;
};
 
layout (std430, binding = 3) buffer _meshlets
{
  Meshlet meshlets[];
} u_MeshletBuffer;

layout (std430, binding = 4) buffer _meshletVertices
{
  uint meshletVertices[];
};

#define MAX_COLORS 10
vec3 meshletcolors[MAX_COLORS] =
{
  vec3(1,0,0), 
  vec3(0,1,0),
  vec3(0,0,1),
  vec3(1,1,0),
  vec3(1,0,1),
  vec3(0,1,1),
  vec3(1,0.5,0),
  vec3(0.5,1,0),
  vec3(0,0.5,1),
  vec3(1,1,1)
};

void main()
{
	const uint mi = gl_WorkGroupID.x;
	const uint threadId = gl_LocalInvocationID.x;

	const uint vertexCount = u_MeshletBuffer.meshlets[mi].vertexCount;

	for(uint i = 0; i < vertexCount; ++i)
	{
		uint vertexOffset = u_MeshletBuffer.meshlets[mi].vertexOffset;

		uint vertexIndex = meshletVertices[vertexOffset + i];

		vec3 vertexPosition = u_VertexBuffer.vertices[vertexIndex].Position;

		mat4 mvp = u_MvpObject.proj * u_MvpObject.view * u_MvpObject.mdlSpace;
		vec4 transformedPosition = mvp * vec4(vertexPosition, 1.f);

		gl_MeshVerticesNV[vertexIndex].gl_Position = transformedPosition;
		if(vertexIndex < 3)
		{
		v_out[vertexIndex].color = vec4(1, 1, 1, 1);
		}
		else
		{
		v_out[vertexIndex].color = vec4(1, 0, 0, 1);
		}
//		v_out[i].color = vec4(meshletcolors[mi%MAX_COLORS], 1.0);
	}

	uint indexCount = u_MeshletBuffer.meshlets[mi].triangleCount * 3;

	gl_PrimitiveCountNV = u_MeshletBuffer.meshlets[mi].triangleCount;

	for(uint i = 0; i < indexCount; ++i)
	{
		gl_PrimitiveIndicesNV[i] = u_TriangleBuffer.triangles[u_MeshletBuffer.meshlets[mi].triangleOffset + i];
	}


}