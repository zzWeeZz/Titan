#version 460

#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_16bit_storage: require
#extension GL_NV_mesh_shader: require

#define  MAX_VERTEX_COUNT 64
#define  MAX_PRIMITIVE_COUNT 124

#define GROUP_SIZE 1

layout (local_size_x = GROUP_SIZE) in;
layout (triangles, max_vertices = MAX_VERTEX_COUNT, max_primitives = MAX_PRIMITIVE_COUNT) out;


layout (location = 0) out PerVertexData
{
	vec4 color;
	vec2 texCoord;
} v_out[];


layout (binding = 0) uniform MvpBufferObject
{
	mat4 view;
	mat4 proj;
	mat4 mdlSpace;
} u_MvpObject;

struct Vertex
{
	vec4 Position;
	vec4 Color;
	vec4 Normal;
	vec4 Tangent; 
	vec2 TexCoords;
	vec2 padding;
};

layout (std430, binding = 1) buffer _vertices
{
  Vertex vertices[];
} u_VertexBuffer;

layout (std430, binding = 2) buffer _triangles
{
  uint triangles[];
} u_TriangleBuffer;

struct Meshlet
{
  uint vertexOffset;
  uint triangleOffset;
  uint vertexCount;
  uint triangleCount;
};
 
layout (std430, binding = 3) buffer _meshlets
{
  Meshlet meshlets[];
} u_MeshletBuffer;

layout (std430, binding = 4) buffer _meshletVertices
{
  uint meshletVertices[];
} u_MeshletVertexBuffer;

#define MAX_COLORS 10
vec3 meshletcolors[MAX_COLORS] =
{
  vec3(1,0,0), 
  vec3(0,1,0),
  vec3(0,0,1),
  vec3(1,1,0),
  vec3(1,0,1),
  vec3(0,1,1),
  vec3(1,0.5,0),
  vec3(0.5,1,0),
  vec3(0,0.5,1),
  vec3(1,1,1)
};

const uint g_VertexLoops = (MAX_VERTEX_COUNT +  GROUP_SIZE - 1) / GROUP_SIZE;
const uint g_PrimReadLoops = (3 * MAX_PRIMITIVE_COUNT + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4);

vec3 GetRandomColor(
	uint _seed)
{
	uint hash = (_seed ^ 61) ^ (_seed >> 16);
	hash = hash + (hash << 3);
	hash = hash ^ (hash >> 4);
	hash = hash * 0x27d4eb2d;
	hash = hash ^ (hash >> 15);
	return vec3(float(hash & 255),
				float((hash >> 8) & 255),
				float((hash >> 16) & 255)) / 255.0;
}
void main()
{
	const uint meshletIndex = gl_WorkGroupID.x;
	const uint threadId = gl_LocalInvocationID.x;
	Meshlet meshlet = u_MeshletBuffer.meshlets[meshletIndex];

	for(uint loop = 0; loop <g_VertexLoops; ++loop)
	{
		uint v = gl_LocalInvocationID.x + loop * GROUP_SIZE;

		v = min(v, meshlet.vertexCount - 1);

		const uint VertexIndex = u_MeshletVertexBuffer.meshletVertices[meshlet.vertexOffset + v];
		Vertex vertex = u_VertexBuffer.vertices[VertexIndex];

		const mat4 mvp = u_MvpObject.proj * u_MvpObject.view * u_MvpObject.mdlSpace;
		gl_MeshVerticesNV[v].gl_Position = mvp * vertex.Position;
		v_out[v].color = vec4(meshletcolors[meshletIndex%MAX_COLORS],1.f);
	}


	uint primreadBegin = meshlet.triangleOffset;
	uint primreadIndex = meshlet.triangleCount * 3;
	uint primreadMax   = primreadIndex;
	for(uint loop = 0; loop < primreadIndex; ++loop)
	{
		uint p = gl_LocalInvocationID.x + loop * GROUP_SIZE;
		p = min(p, primreadMax);
		 uint topology = u_TriangleBuffer.triangles[primreadBegin + loop];

		gl_PrimitiveIndicesNV[p] = topology;
	}

	if(threadId == 0)
	{
		gl_PrimitiveCountNV = meshlet.triangleCount;
	}
}









//for (uint vLoop = 0; vLoop < g_VertexLoops; ++vLoop)
//	{
//		uint v = threadId + vLoop * GROUP_SIZE;
//		
//
//		v = min(v, meshlet.vertexCount - 1);
//
//		
//		uint vertexIndex = u_MeshletVertexBuffer.meshletVertices[(meshlet.vertexOffset + v)].x;
//		Vertex vertex = u_VertexBuffer.vertices[vertexIndex];
//
//		const mat4 mvp = u_MvpObject.proj * u_MvpObject.view * u_MvpObject.mdlSpace;
//		gl_MeshVerticesNV[v].gl_Position = mvp * vec4(vertex.Position, 1.0f);
//
//		v_out[v].color = vec4(meshletcolors[v%MAX_COLORS],1.f);
//	}
//
//	uint packedTriangleOffset = meshlet.triangleOffset / 4;
//	uint packedTrianglesMax = (3 * meshlet.triangleCount - 1) / 4;
//
//	for (uint pLoop = 0; pLoop < g_PrimReadLoops; ++pLoop)
//	{
//		uint localTriangleIndex = threadId + pLoop * GROUP_SIZE;
//		localTriangleIndex = min(localTriangleIndex, packedTrianglesMax);
//
//
//		writePackedPrimitiveIndices4x8NV(4 * localTriangleIndex, u_TriangleBuffer.triangles[packedTriangleOffset + localTriangleIndex]);
//	}
//
//	if(threadId == 0)
//	{
//		gl_PrimitiveCountNV = meshlet.triangleCount;
//	}